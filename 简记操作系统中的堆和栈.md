# 操作系统中的堆和栈

​	应用程序在运行时，需要将在运行时需要用到的资源加载进入内存中，以虚拟内存的形式表现给应用程序。其中内存地址空间按照由高到低的顺序可以被粗略划分为以下五个部分

1. 栈区。从内存地址高处开始向下增长，其空间由系统自动分配与释放，用来存放函数完毕后下条指令的内存地址，当前函数栈的栈底地址，函数的参数值，函数局部变量的值，函数的返回值。
2. 未使用的内存空间。
3. 堆区。从内存地址低处开始向上增长，其内存空间由用户手动申请，由编译器进行分配，需要用户在不使用的时候将空间手动回收，如果在程序结束时仍存在未回收的内存空间，则由系统进行回收。
4. 代码区。程序函数的二进制代码就存放在此处。
5. 文字常量区。用来存放一些在编译时就存在的字符串的值。
6. 全局变量区，用来存储全局变量与静态变量。根据初始化与否可以再向下划分
   1. 未初始化的数据。
   2. 初始化的数据。



这里主要讨论的是其中的栈区和堆区。

# 栈与堆的简介

​	栈中的空间都是由系统分配和回收的。在调用函数时，函数的参数会按照从右往左的方向压入栈中，随后是其中所使用到的局部变量，最后是函数的返回值与函数的返回地址。栈的内存空间是连续的，一段函数会占用一段连续的内存空间来存储相关的数据，相关数据之间不存在有无关的数据。当函数被执行完毕后，函数中的值就会被出栈，占据的内存空间被系统回收。

​	堆中的空间则是由用户手动分配与回收的，如果相关的变量在使用完后用户不手动回收，则相关内存空间会被一直占据，直至应用生命周期结束，相关内存空间被系统回收。连续的数据在堆空间中的分配并不是连续的。操作系统中存在有一个链表，用以记录所有空闲内存空间的头部地址与其对应的大小。当我们申请在堆中分配空间时，操作系统会去遍历这个链表，得到其中第一个空闲空间大于所需空间的空闲内存地址，然后操作系统会将这份内存空间标记为已被使用、将其挪出链表并且把这块内存空间交给用户使用。由于这样的特性，我们在实际使用中申请到的内存空间往往并不是连续的，因为这个链表所记录的内存空间可能分散在内存的各处。

# 栈与堆的差别

1. 管理方式不同。栈的内存空间由系统管理，而堆的空间由用户管理。
2. 可分配空间大小不同。栈可分配的内存空间和堆的完全不是一个量级。一个进程可获得的栈空间大小，在64位 Windows 上是1M（有说法是 2M，待考证），在64位 Linux 中是10M；而可供堆空间分配的基本上就是整个虚拟内存的地址空间。
3. 地址增长方向不同。栈空间的内存地址是自高向低增长的，堆空间的内存地址是自低向高增长的。
4. 内存分配方式不同。堆空间的内存是动态分配的，栈空间的内存同时具有静态与动态两种分配方式，但这里的动态分配不与堆的动态分配相似。
5. 分配效率的不同。栈空间的内存都是由系统分配的，其在底层硬件上存在支持：有专门的CPU寄存器存储栈顶指针，有专门的机器指令来进行压栈入栈操作；而堆空间的分配则没有这种支持，需要语言予以实现，并且内存的分配依赖于遍历记录空闲内存的链表，效率大打折扣，这还没算上在调用分配/回收函数时可能产生的用户态与核心态之间的转换和产生的内存碎片的损耗。

