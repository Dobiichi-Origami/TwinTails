# 第二章 信息的表示与操作

[toc]

## 信息的存储

在计算机中，信息是以01二进制模式串组成的字节形式存储于计算机中的。数据与所需要执行的语句若不加区分，在计算机看来都是一样的东西。

### 十六进制表示

1. 虽然计算机中的信息都是二进制表示的，但是我们也经常用十六进制来表示数据，这样子表示的数据数据密度大，可以节省很多空间

### 数据大小

1. 每台计算机都会有自己的字（word）大小，通常来说这个大小是 32bits（4Bytes）和 64bits（8Bytes）。字大小决定了CPU一次能够并行处理的二进制位的数量，CPU以这个字大小为基本单位读写、处理数据。这里的字大小与稍后说到的用于表示不同数据大小的word size不同，在那个语境中，一个word的大小是16bits（2Bytes）
2. C语言中每种基本类型都具有一定的大小，其大小一般来说和我们平常的认知一致，但是在不同的位数下，他们有不同的大小，对，我说的就是long和指针两种类型。在32-bit下，long和指针都是 4Bytes 长，而在64-bit下，它们则是 8Bytes 长。所以在32-bit的环境中想使用长整型的数据空间，请用int64_t

### 地址编码和字节顺序

1. 在计算机中，虚拟内存是以一连串的单字节所组成的字节数组表示的。我们以从0到$2^{w}-1$的数字序列来给这些字节编码地址（其中 $w$ 是你CPU的位数大小），这样组成了地址空间。
2. 不同体系的计算机会具有不同的字节顺序，以常见的 x64-64和 arm 架构为例，其中的字节顺序为小端序，即在内存中，一条数据的高比特位的数据会存储在相对高的地址空间中，低比特位的数据会存储在相对低的地址空间中；大端序反之。但是一条数据都是连续存储的，无关于大端序还是小端序。举个例子，如果我们有一个数字0x12345678，按照内存的存储方式，我们将其划分为 12 34 56 78 四个段。在小端序的计算机中，按照地址从低到高的顺序存储，这四个段的顺序为 78 56 34 12；在大端序的计算机内存中则是 12 34 56 78。

### 字符串表示

1. 字符串都是由ascii码表示的字符序列

### 代码的表示

1. 在不同体系中，计算机拥有不同的的指令集。因此相同的代码在不同体系架构中编译出来的结果也会大相径庭。一个体系架构所编译出来的代码不可直接在另一个平台上运行。就算是同一个体系架构但是位数不同的系统所编译出来的代码也不一定能够直接运行（64位系统编译的程序无法在32位系统上运行）

### 隆重介绍布尔代数

1. 就是 C 位运算里面的内容

### C 中的位运算

1. 同上

### C 中的逻辑运算

1. C 的基础内容，不做过多陈述

### C 中的位移运算

1. 左位移只有一种，将高位的n位截断，再将剩下的位向高位移动n位，补n个0
2. 而右位移有两种，分算数位移和逻辑位移。在算数位移中，高位空缺以原本的最高位二进制数补全。即若高位是1则补1，高位为0就补0。在逻辑位移中则统一补零。

## 整数表示

整数的二进制表示有两种形式，二进制补码和无符号形式。前者可以表示负整数，零和正整数；而无符号，顾名思义，只能用来表示非负整数。它们分别有不同的固有属性。

### 整数数据类型

1. 在C语言中有大量的整数类型，包括char，short，int等

### 无符号编码

1. 这是最基础的编码方式，数字和其二进制模式串所表示的大小是一致的。计算就是普通的二进制运算

### 二进制补码编码

1. 无符号编码只能用来表示一定范围内的非负整数，无法表示负数，二进制补码的编码形式弥补了这一空缺。这种编码方式将最高位的符号反转为负号，其他的符号表示保持不变。因此，二进制补码的编码方式能够表示$-2^{n-1}$ ~ $2^{n-1}-1$ 共 $2^n$ 个数字（其中，$n$ 为计算机系统的位数）。在计算上，二进制补码与无符号编码相同，无需任何额外的计算步骤和方法

### 有符号与无符号之间的转换

1. 有符号数和无符号数之间的转换是二进制模式串解释方式的转换，并不会改变原本的二进制串模式。
2. 在进行有符号和无符号数的转换时，可能会出现溢出

### C 中的有符号和无符号数

1. 在 C 中，一个整数默认是有符号的，除非你显式的在末尾加上后缀U，这样子就会被当成无符号数来处理
2. 在 C 中，有符号数和无符号数一同运算时，编译器会隐式的将有符号数转换成无符号数来解释。

### 整数位表示的扩展

1. 对于无符号的整数而言，将其位数扩展只需要在前面加上相应位数的0即可
2. 对于有符号的整数而言，我们需要考虑有符号扩展。根据最高位的数字决定加什么数：如果是1就在前面加上相应位数的1，反之加0
3. size_t 是一个无符号整数别名，在32-bit系统下为 unsigned int ，在64-bit系统下为 unsigned long long

### 截断数字

1. 很简单，硬截就是了

### 对有符号和无符号选取的建议

1. 没有建议

### 整数运算

### 无符号加法

1. 如果与有符号数一同进行运算，会将有符号数隐式转换成无符号数
2. 如果发生了溢出，直接截断多余二进制位，取剩下的模式串即可
3. 无符号取相反数时，对二进制模式串按位取反后加一即可得到相反数（为了计算减法）

### 有符号加法

1. 同上，无论发生上溢出还是下溢出，只要截断多余高二进制位，取剩下的模式串即可
2. 有符号取相反数也同无符号数。这里再一次从侧面证明了有符号和无符号只是解释方式不一样，它们的本质是相同的。

### 有符号取反

1. 刚才说过了，不再重复

### 无符号乘法

1. 无符号数的乘法遵循普通的竖式运算法则，只不过这里用的是二进制表示而已。
2. 如果发生了上溢出，简单截断即可

### 有符号乘法

1. 有符号乘法实际上也很简单，将有符号数的二进制串当成无符号数进行乘法，最后将结果二进制模式串解释成有符号数即可。
2. 截断同上

### 乘以常量

1. 有这么一个事实，一个数乘以另一个数可以被拆分为一个数分别乘以几个2的幂数再相加的结果
2. 其原理是位移运算的速度远远快于按部就班执行乘法运算，因此将一个乘法运算拆成一个数的几个位移结果再相加的和运算会快得多。

### 除以2的幂

1. 直接位移就好了
2. 由于位移运算的特殊性，我们算出来的结果往往不是准确的（体现在被位移位中如果存在1的时候，会导致丢失精度），基于此，我们需要进行取整操作
3. 一共有三种常用的取整操作：向零取整，向上取整，向下取整。
4. 在向零取整中，正数结果采用向下取整，负数结果采用向上取整。
5. 为了实现向上取整，我们需要将被除数加上一个偏置，这个偏置为 $2^n-1$ ，其中 $n$ 为幂的大小。这样子就能保证结果向上取整（具体原理请自查）

### 整数运算的思考

1. 略过不表

## 浮点数

1. 历史上有很多各种各样的浮点数表示方式，但是后面被IEEE 754全部干掉了，IEEE 754成为了现行的浮点数标准

### 二进制分数

1. 分数的表示和整数类似，只不过这里是 2 的负数幂，不做过多解释
2. 受限制于二进制，有些分数是无法精确表达的，例如 $1/3$ 就不能用二进制准确表示出来。

### IEEE 浮点数表示法

1. IEEE 浮点数表示法将小数表示为左边的形式：$(-1)^s*M*2^E$，其中 S 为符号位，M 为分数部分，E 为指数部分
2. 理论上这种表示方法可以表示出允许范围内的所有整数，但是小数的精度堪忧，尤其是越靠近数轴两端，小数的精度越差

3. IEEE 浮点数表示法把小数表示为二进制串，形如右边所示：符号位（1位）+ 指数位（8位或11位）+ 小数位（23位或52位），取决于精度不同，分为单精度浮点数（32位）和双精度浮点数（64位）两种
4. 浮点数的一般表示流程是这样的：（小数位计算出来的结果 + 1）* 1 << {指数位的计算结果 - 偏置} * （-1​）^ 符号位，计算结果就是该浮点数的对应的一般二进制模式串，根据需求可以转化为十进制计算。
5. 偏置等于 $2^{n-1}-1$ ，其中 $n$ 是指数位的总数
6. 当指数位为全零时，是一种被称作『非正则化』的特殊形式，这种特殊形式下小数位计算结果无需加一，目的是为了精确表示零附近的小数。
7. 当指数位为全一时，又具有两种特殊情况：当小数位全为0时，表示无穷，根据符号位的不同又分为正无穷与负无穷。当小数位不全为0时，则表示 NaN（Not a Number，非数字）

### 示例数字

1. 略过不表

### 取整

1. 浮点数的取整靠观察最后一个保留位后三位的形式（xx……x.y……yzzz，其中最右边的y就是我们最后一个保留位，我们要对他进行取整操作，zzz是我们所需要观察的模式串）：如果zzz小于100，则不进位，如果zzz大于100，则进位（最后一个y+1），如果zzz刚好等于100，当最后一个y为1时进位，若为零则不进位。

### 浮点数运算

1. 由于精度问题，浮点数的运算满足交换律，但不满足结合律；原因是如果一个数太小，而另一个数太大的话，结果中较小那个数的部分会被当做无用精度舍弃掉。
2. 所以编译器最好不要对浮点数运算做任何的优化，否则可能会出很严重的bug

### C 语言中的浮点数运算

1. 略过不表

# 完结