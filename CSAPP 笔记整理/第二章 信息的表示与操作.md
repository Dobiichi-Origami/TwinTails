# 第二章 信息的表示与操作

[toc]

## 信息的存储

在计算机中，信息是以01二进制模式串组成的字节形式存储于计算机中的。数据与所需要执行的语句若不加区分，在计算机看来都是一样的东西。

### 十六进制表示

1. 虽然计算机中的信息都是二进制表示的，但是我们也经常用十六进制来表示数据，这样子表示的数据数据密度大，可以节省很多空间

### 数据大小

1. 每台计算机都会有自己的字（word）大小，通常来说这个大小是 32bits（4Bytes）和 64bits（8Bytes）。字大小决定了CPU一次能够并行处理的二进制位的数量，CPU以这个字大小为基本单位读写、处理数据。这里的字大小与稍后说到的用于表示不同数据大小的word size不同，在那个语境中，一个word的大小是16bits（2Bytes）
2. C语言中每种基本类型都具有一定的大小，其大小一般来说和我们平常的认知一致，但是在不同的位数下，他们有不同的大小，对，我说的就是long和指针两种类型。在32-bit下，long和指针都是 4Bytes 长，而在64-bit下，它们则是 8Bytes 长。所以在32-bit的环境中想使用长整型的数据空间，请用int64_t

### 地址编码和字节顺序

1. 在计算机中，虚拟内存是以一连串的单字节所组成的字节数组表示的。我们以从0到$2^{w}-1$的数字序列来给这些字节编码地址（其中 $w$ 是你CPU的位数大小），这样组成了地址空间。
2. 不同体系的计算机会具有不同的字节顺序，以常见的 x64-64和 arm 架构为例，其中的字节顺序为小端序，即在内存中，一条数据的高比特位的数据会存储在相对高的地址空间中，低比特位的数据会存储在相对低的地址空间中；大端序反之。但是一条数据都是连续存储的，无关于大端序还是小端序。举个例子，如果我们有一个数字0x12345678，按照内存的存储方式，我们将其划分为 12 34 56 78 四个段。在小端序的计算机中，按照地址从低到高的顺序存储，这四个段的顺序为 78 56 34 12；在大端序的计算机内存中则是 12 34 56 78。

### 字符串表示

1. 字符串都是由ascii码表示的字符序列

### 代码的表示

1. 在不同体系中，计算机拥有不同的的指令集。因此相同的代码在不同体系架构中编译出来的结果也会大相径庭。一个体系架构所编译出来的代码不可直接在另一个平台上运行。就算是同一个体系架构但是位数不同的系统所编译出来的代码也不一定能够直接运行（64位系统编译的程序无法在32位系统上运行）

### 隆重介绍布尔代数

1. 就是 C 位运算里面的内容

### C 中的位运算

1. 同上

### C 中的逻辑运算

1. C 的基础内容，不做过多陈述

### C 中的位移运算

1. 左位移只有一种，将高位的n位截断，再将剩下的位向高位移动n位，补n个0
2. 而右位移有两种，分算数位移和逻辑位移。在算数位移中，高位空缺以原本的最高位二进制数补全。即若高位是1则补1，高位为0就补0。在逻辑位移中则统一补零。

## 整数表示

整数的二进制表示有两种形式，二进制补码和无符号形式。前者可以表示负整数，零和正整数；而无符号，顾名思义，只能用来表示非负整数。它们分别有不同的固有属性。

### 整数数据类型

1. 在C语言中有大量的整数类型，包括char，short，int等

### 无符号编码

1. 这是最基础的编码方式，数字和其二进制模式串所表示的大小是一致的。计算就是普通的二进制运算

### 二进制补码编码

1. 无符号编码只能用来表示一定范围内的非负整数，无法表示负数，二进制补码的编码形式弥补了这一空缺。这种编码方式将最高位的符号反转为负号，其他的符号表示保持不变。因此，二进制补码的编码方式能够表示$-2^{n-1}$ ~ $2^{n-1}-1$ 共 $2^n$ 个数字（其中，$n$ 为计算机系统的位数）。在计算上，二进制补码与无符号编码相同，无需任何额外的计算步骤和方法

### 有符号与无符号之间的转换

1. 有符号数和无符号数之间的转换是二进制模式串解释方式的转换，并不会改变原本的二进制串模式。
2. 在进行有符号和无符号数的转换时，可能会出现溢出

### C 中的有符号和无符号数

1. 在 C 中，一个整数默认是有符号的，除非你显式的在末尾加上后缀U，这样子就会被当成无符号数来处理
2. 在 C 中，有符号数和无符号数一同运算时，编译器会隐式的将有符号数转换成无符号数来解释。

### 整数位表示的扩展