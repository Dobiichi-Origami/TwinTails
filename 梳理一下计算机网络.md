# 引言

​	感觉自己在这块内容里学了很多，也了解了很多，有了大概的知识框架。虽然这篇文章说是讲传输层TCP和UDP相关的东西，但是后面可能还会涉及到一些HTTP相关的内容，其他的也说不定，看面试会问什么就写什么好了。文风极其随意。

# 什么是传输层

​	传统的TCP/IP五层模型将网络传输划分为五个层次（阶段），分别是：

应用层：供程序设计者使用，提供一系列抽象好的用于网络传输的功能，如HTTP（HyperText Transport Protocol 超文本传输协议）、FTP（File Transport Protocol 文件传输协议）等。

传输层：连接网络层和应用层，使用来自网络层的服务对应用层的数据进行打包，一般常见的主流协议就两种，UDP（User Datagram Protocol 用户数据报协议）和TCP（Transport Control Protocol 传输控制协议），这里主要讲的就是传输层

网络层：负责路由以及把分组报文发送给目标网络或主机。

数据链路层和物理层：把报文发送出去的）

这里重点讲的是传输层，因为面试出现的次数会很多，是重点考察内容，相对而言，从网络层到物理层这些我们都不考虑讲的原因也是因为不考。

# 传输层的作用

​	传输层作为利用网络层为应用层提供服务的层次，它提供了一种进程到进程的逻辑连接。

​	虽然一个实际的数据包传输要经过TCP/IP模型的五层，跋山涉水之后才能到达目标计算机上；但是这种物理链接是被屏蔽的，用户需要关注的只是由传输层所提供的抽象出来的逻辑连接。它假设源主机和目标主机的传输层之间存在有一条直连的逻辑连接，两台主机之间可以通过这条逻辑连接直接向对方交换数据，不需要自己动手考虑数据包是如何被路由、被编解码的，省心很多。

# 传输层基础知识扫盲

​	为了了解传输层两大传输协议TCP和UDP是如何工作的，我们需要先了解一些基本的概念，为接下来详细铺开了解TCP和UDP奠定基础。

## 套接字

​	传输层是为应用层提供服务的，应用层在计算机上的具体实现即是一个程序，也是一条进程。我们要为应用层提供服务，首先就要知道我们是为谁提供服务。基于以上的目的，我们使用套接字（Socket）来定义一台主机上的某个应用程序或进程。例如下面这个指向本地计算机8080进程的套接字

> localhost:8080

一段套接字可以根据半角的冒号分为前后两段。前面一段定义了主机在网络中的地址，可以用域名经DNS解析为地址，也可以直接写IP地址；后面一段定义了主机中的进程的端口号，是一个0~$2^{16}$的整数，根据你的实际需要填写对应进程的端口号。有了这些，我们就可以定位网络中任意两个正在运行的进程并且连接他们进行数据传输了。

## 封装和解封装

​	传输层为了实现自己的功能，包括但不限于指定源主机和目标主机、流量控制、差错控制、拥塞控制等，会将一些必要的信息添加在用户数据的头部。添加信息的过程我们称之为封装，通常发生在信息将被发送前；删除信息的过程我们称之为解封装，通常发生在将用户数据转发给用户进程前。

## 多路复用和多路分解

​	一台电脑可以同时运行多个程序，也必然会存在多个需要网络通信的进程，但是我们的传输层只有一个。为了同时为多个应用层服务提供传输层的服务，传输层可以同时接收来自多个数据源的数据，并且将它们打包发送给网络层，我们称之为多路复用；反之，从网络层接收数据并且将它们分发给多个不同的应用层服务我们称之为多路分解。

## 流量控制

​	现实总是很残酷，计算机的处理速度不可能是光速，总会存在一个速度的上限，网络传输也是如此。由于源主机数据生产速率和目标主机数据消耗速率的差异，在网络传输中会出现两种情况：

1. 源主机数据发送速率跟不上目标主机数据消耗速率，导致目标主机出现空载的情况
2. 目标主机数据消耗速率跟不上源主机数据发送速率，导致目标主机出现过载的情况

​	对于第一种情况我们其实不需要担心，顶多只是网络利用率不高而已，没有什么实际上的影响，但是第二种情况导致的目标主机满载可能会严重影响任务处理的速率。为了解决第二种情况，我们需要实现流量控制来控制源主机的数据发送速率，以期望匹配上目标主机的数据消耗速率从而达到供需平衡。流量控制的实现粗略包含了以下几个方面。

### 推或拉

​	在数据传输的过程中，接收方和发送方之间的数据交换方式类型可以大致分为推和拉两种。推即是接收方没有请求的情况下发送数据，而拉则是接收方在请求之后发送数据，前者是我们需要进行流量控制的对象

### 缓冲区

​	实现缓冲区是我们进行流量控制的一种基本手段。数据在被生产或者接受之后并不会立刻发送到它的目的地（源主机传输层和目标主机传输层或应用层应用），而是会被先存放在缓冲区中，默默等待轮到自己被拉取。期间缓冲区的可用大小会随着数据的存取而变化，当缓冲区满了之后，接收方便不会再接收新的数据，直到一定量的数据（可能是一个单位或者是好几个单位，取决于具体的实现）被拉取出去留出一定的空间后，接收方才会再重新接收新的数据。

## 差错控制

​	不光数据处理速度没那么理想，就连传输质量都和阿尔法罗密欧的品控一样不靠谱。在互联网中，数据的传输总是会因为这样那样的原因，要么可能丢了，要么来晚了导致数据的顺序颠倒了，要么原有数据变了，总之会出千奇百怪的幺蛾子。为了处理这些错误的情况，我们提出了差错控制的思想。差错控制所负责的内容主要包括了以下几个方面

+ 找出并丢弃损坏的分组

+ 记录丢弃和丢失的分组并等待重传

+ 识别重复的分组

+ 缓冲失序的分组，等待丢失的分组被重传

以上内容构成了差错控制的主体，为了实现它，我们需要提出一些新的概念

### 序号

​	为了得知分组是否失序、丢失，我们需要对我们需要发送的分组进行编号，有了序号之后，接收方就可以知道以上情况的发生，从而做出相应的反应来进行处理。

> 序号的范围取决于具体实现所分配给序号的二进制位数，处于0~$2^{m}$之间（m为序号在传输层分组头部所占用的位数），并且是首尾相接的环状结构，当序号达到最大值时，下一个序号会被置为0

### 确认

​	当接收方接收到了数据以后，接收方需要发送一些内容来告知发送方，自己已经正确接收到了自己想要的数据，对于那些损坏或不符合预期的数据则不发送，这些内容我们便称之为确认。发送方在发送了一份分组之后便会打开一个计时器（TImer），如果计时器的时间到时了发送方还没有收到对应的确认，那么接收方就会重发这份分组，重置计时器的时间重新开始计时，接收方会循环上述过程直到收到了确认为止。

## 把流量控制和差错控制结合起来

​	流量控制需要在发送端和接收端实现两个缓冲区以缓冲数据，稳定数据的收发速率；差错控制需要实现序号和确认来完成自动纠错。我们把以上两个结合在一起，就有了传输层最基础的一个印象：一条两头带有编号缓冲区的抽象数据管道。我们大致来看一下它是怎么传输数据的：

+ 在有数据从应用层传递下来时，传输层会把这个数据放在对应编号为X（下一个空闲的编号）的缓冲区中变成分组，等待收到信号轮到自己被发送出去。
+ 经过了一条抽象的数据管道后，这个分组被发送到了目的地主机的传输层中，传输层会检查它是否失序或被损坏，从而决定是丢弃还是把它存入编号为X的对应缓冲区中。
+ 被放入缓冲区后，它只需要等待应用层来拉取它即可，而接收端还会向发送端发送一条确认，表明自己已经正确收到了数据。
+ 这里还有一种情况是这个分组在管道传输的过程中不知道丢到哪里去了，接收端压根就没有收到这个东西。此时发送端的计时器到时之后便会重发这个分组。
+ 当发送端收到这个确认之后，便会把该分组所占缓冲区位置给空出来，以待之后使用。

### 滑动窗口

​		我们在这里再细说一下缓冲区的实现问题。由于缓冲区的特性（需要不断更改序号来维持数据传输的需求），我们可以将缓冲区视为一个滑动窗口，其有一个固定或变化的大小m（一般取决于实现），在整个序号空间大小的循环数组上不断向序号增大的方向滑动。每当有数据请求被发送时，传输层就会寻找这个数组中第一个没有被占据的空间并且把数据放入其中。每当有数据被确认收到之后，窗口便向右滑动，将被确认的数据滑出窗口，空出相应的空间来接收新数据。一旦窗口满了，传输层便暂停接收新数据，等待空出足够空间后再重新开始接收。

## 拥塞控制

​	拥塞控制有别于流量控制，流量控制是为了防止接收端被分组淹没导致过载，拥塞控制是为了防止传输层发送的分组过多，把整个管道（网络的传输路径）给堵上了。分组的传输虽然可以看做是分组在一条抽象的管道里直接往返与收发两端，但是实际上分组要想到达目的地，会被路由层层转发，经手多个节点后才会到达目的地。每个节点本身也需要实现数据的吞吐才能将分组转发到下一个目的地，而数据的吞吐、处理也是花时间的；如果网络中的流量过大，节点可能会因为处理速度跟不上吞吐数据而超载，最终导致网络的拥塞。我们这里假定网络层及以下的层次没有实现拥塞控制，需要传输层自行实现拥塞控制，TCP便是实现了拥塞控制的协议。

## 无连接服务和面向连接服务

​	这里的连接和我们平时指的连接不是一个东西。在传输层中，无连接服务指的是发送出去的分组是互相独立的；换成人话说就是，在传输分组时，收发双方之间不会单独建立一条逻辑信道，传输结束后更不可能再单独拆除这条逻辑信道。所有分组之间就算他们存在逻辑上的顺序性，也都会被当成一个个独立无关的分组进行发送，因为接收端根本不知道什么时候第一个分组会来，什么时候最后一个分组被发送结束。我们没办法在这种情况下实现流量控制、差错控制和拥塞控制。

​	而面向连接服务就是无连接服务的反面。它会在连接开始之时建立信道，分组发完之后再拆除信道。这样发送出去的分组，与其同一条信道中的其他分组形成了依赖关系，他们之间是有关系的；不同信道之间的分组则是无关的。有了这样的性质，我们便可以实现流量控制、差错控制和拥塞控制。

# 简单的几个传输层协议

​	这几个简单的传输层协议是我们理解后面TCP和UDP的基础，有必要认真理解一下。

## 最基础的简单连接协议

​	在这个协议中，我们假设接收方的处理能力永远高于发送方。这个协议没有实现流量控制和差错控制，发送方传输层在收到了来自应用层的数据以后，就将其封装成分组，直接发送到接收方传输层，由接收方传输层解封装后传递给应用层。我们把这个协议稍加改动，就可以得到我们接下来会讲到的UDP。

## 停止-等待协议

​	这个协议是上面简单连接协议的升级版。在停止-等待协议中，我们分别在发送方和接收方处实现了一个大小恒为1的滑动窗口用作缓冲区，基于此，我们就可以实现最基础的流量控制和差错控制，下面简述了停止-等待协议的工作流程：

+ 在收到了来自应用层的数据之后，发送方传输层将数据缓冲到滑动窗口中唯一的空间中。
+ 发送方传输层将数据封装，给他加上一系列信息（目的套接字、源套接字、序号、校验和等）打包成分组后发送出去，并且开启一个计时器（Timer）
+ 根据接收情况，接收方会有不同的动作
  + 如果接收到了没有问题而且正好是自己想要的数据，并且滑动窗口内存在空间，接收方传输层会将分组缓冲到滑动窗口中唯一的空间里等待传输层应用拉取，并发送一个ACK（acknowledgment check）给发送端传输层表示自己已经收到了信息
  + 如果遇到了以下的两种情况之一：没收到分组，分组在传输过程中损坏，接收方都会简单将信息丢弃，继续等待下一个分组的到来，不会发送ACK；但如果收到的分组没损坏却不是自己想要的分组，则接收方会重复发送一个ACK给发送方并将分组丢弃
+ 根据ACK到达与否，发送方也会有不同的动作
  + 如果接收到了ACK且ACK确认号正确，发送方传输层会将缓冲区区域空出，关闭计时器，等待应用层向传输层传输数据
  + 如果没有接收到ACK或ACK确认号错误并且计时器超时，发送方会重发分组，重置计时器，继续等待ACK的到来。

​	上面就实现了基础的差错控制（错了就丢等重发）和流量控制（缓冲区大小仅为一，一次只能发一个分组），需要简单指出的是，这里的序号只会在0和1之间不断循环（因为缓冲区只有一的大小）。这里的ACK中会包含下一个预期收到的分组的序号，称为确认号。

## 回退N帧协议

​	停止-等待协议一次只能发一个分组，效率是可想而知的低下，为了能够高效利用当代计算机网络的大水管，我们提出了回退N帧协议，这是上面等待-停止协议的缓冲区加大加量升级版（划掉）

​	上面停止-等待协议的序号占用分组头部一个bit的空间，为$1/8$字节，其范围只能包含0和1（$2^1=2$）两个数字，而这里的回退N帧协议则可以使用m个bit的空间，为$m/8$字节，其范围可以包括0到$2^m-1$共$2^m$个数字。相配套的，**发送方**缓冲区窗口大小肯定也不能只是1，取决于具体实现，我们将其设为$n$，但是**接收方**缓冲区窗口大小不变，恒为1，即一次还是只能接收一条数据。

​	发送方的缓冲区窗口可以被大致分为两个部分：已发送而未确认的部分和等待发送的部分。应用层将数据发送给发送方传输层之后，传输层将其打包成分组但不会立即发送，而是将其放入缓冲区窗口下一个存在的空位中等待发送。分组在被发送出去后仍然会保留在缓冲区窗口中，直到对应ACK的到来，滑动窗口滑动将该分组滑出缓冲区。

### 计时器和重发

​	停止-等待协议实现了计时器，因此他可以重发丢失或损坏的数据。回退N帧协议也是一个道理，其实现了唯一一个计时器，以当前第一个被发送出去等待确认的分组为基准开始计时。当计时器超时时，发送方传输层会将***所有已经发送但是没有被确认的分组***全部重发，并且重置计时器。

### 工作流程

​	当一份数据在传输层之间传输，会发生以下的事情

​	发送方：

+ 当数据从应用层传递给传输层？
  + 如果传输层的缓冲区窗口已满，则传输层暂停接收数据，等待有数据被确认后空出缓冲区窗口，重新接收新数据
  + 如果传输层的缓冲区窗口未满，则传输层接收来自应用层的数据，放入缓冲区窗口并且打包成分组，发送出去
+ 当传输层发送方方收到ACK
  + 如果ACK正确无误且和我们所发送的分组有关系，则将窗口向右滑动到ACK所在位置，并且重置计时器
  + 如果ACK有损坏或者与我们所发送的分组无关，则抛弃ACK，继续等待
+ 当发生超时时，传输层发送方会重发所有未确认的分组，重置计时器（回退N帧的由来）



​	接收方：

+ 当传输层接收方收到分组
  + 如果收到的分组与我们所期盼的分组序号一致，不存在损坏的情况，且缓冲区空闲，则将其放入缓冲区中，发送一个确认号为$(序号+1) mod 2^m$的ACK给传输层发送方，等待应用层拉取分组
  + 如果收到的分组有任何问题或者缓冲区有数据，则直接无视所收到的分组，如果只是不是自己想要的分组，接收方会重新发送一个ACK

### 一个小问题

​	在回退N帧协议中，缓冲区窗口的大小通常为$2^m-1$，个中原因请自行搜索了解

## 选择性重复协议

​	在回退N帧协议中，我们拓展了停止-等待协议，有效利用了网络的空闲带宽，但是这还不够，回退N帧协议中的接收方缓冲区大小仅为1，还有升级空间；而且在网络环境恶劣，丢包、分组损坏的事情经常发生的情况下，回退N帧协议会大量重发已发送的数据包，这会进一步加重网络的拥塞，恶化网络环境。为了完善它，我们又提出了选择性重复协议，他与回退N帧协议有着一些不同：

+ 接收方的缓冲区大小不再为1
+ ACK的确认号不再代表下一个期望接收到的分组序号，而是代表已经接收到的分组序号